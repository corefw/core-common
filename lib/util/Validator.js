/**
 * @file Defines the Validator class.
 *
 * @author Luke Chavers <luke@c2cschools.com>
 * @author Kevin Sanders <kevin@c2cschools.com>
 * @since 5.0.0
 * @license See LICENSE.md for details about licensing.
 * @copyright 2017 C2C Schools, LLC
 */

"use strict";

const BaseClass	= require( "../common/BaseClass" );
const ERRORS	= require( "../errors" );

/**
 * This utility class facilitates validation, especially of JavaScript and JSON
 * objects against JSON Schemas.
 *
 * @memberOf Util
 * @extends Common.BaseClass
 */
class Validator extends BaseClass {

	/**
	 * @inheritDoc
	 */
	initialize( cfg ) {

		const me = this;

		// Call parent
		super.initialize( cfg );

		// Execute immediately, if requested
		if ( cfg.immediate === true ) {

			me.validate();
		}
	}

	/**
	 * The object to be validated.
	 *
	 * @public
	 * @type {Object}
	 */
	get obj() {

		const me = this;

		return me.getConfigValue( "obj", null );
	}

	set obj( /** Object */ val ) {

		const me = this;

		me.setConfigValue( "obj", val );
	}

	/**
	 * The schema that will be used in the validation of `obj`.
	 *
	 * @public
	 * @type {Object}
	 */
	get schema() {

		const me = this;

		return me.getConfigValue( "schema", null );
	}

	set schema( /** Object */ val ) {

		const me = this;

		me.setConfigValue( "schema", val );
	}

	/**
	 * When TRUE, validation will be skipped (passed) if either the `obj` or
	 * `schema` is NULL.
	 *
	 * @public
	 * @type {boolean}
	 * @default false
	 */
	get skipIfNull() {

		const me = this;

		return me.getConfigValue( "skipIfNull", false );
	}

	set skipIfNull( /** boolean */ val ) {

		const me = this;

		me.setConfigValue( "skipIfNull", val );
	}

	/**
	 * When TRUE, validation errors will be thrown verbatim (not wrapped by a
	 * custom error).
	 *
	 * @public
	 * @type {boolean}
	 * @default false
	 */
	get throwTv4Errors() {

		const me = this;

		return me.getConfigValue( "throwTv4Errors", false );
	}

	set throwTv4Errors( /** boolean */ val ) {

		const me = this;

		me.setConfigValue( "throwTv4Errors", val );
	}

	/**
	 * Stores schema `definitions` (refs/references) that will be used to
	 * populate the schema with common schema parts before validation.
	 *
	 * @public
	 * @type {?Object}
	 * @default null
	 */
	get definitions() {

		const me = this;

		return me.getConfigValue( "definitions", null );
	}

	set definitions( /** ?Object */ val ) {

		const me = this;

		me.setConfigValue( "definitions", val );
	}

	/**
	 * Starts a validation operation.
	 *
	 * @param {?Object} [cfg=null] - Optional configuration values that will be
	 *     used to configure the validator prior to validation. Any
	 *     configuration setting that can be passed to the Validator's
	 *     constructor can also be passed here.
	 * @returns {void} Errors will be thrown if validation fails.
	 */
	validate( cfg ) {

		const me = this;

		// Apply New Config
		me.setConfigValues( cfg );

		// Skip if necessary
		if ( me.skipIfNull && ( me.obj === null || me.schema === null ) ) {

			return;
		}

		// Do it
		me._validateObject( me.obj, me.schema );
	}

	/**
	 * This method executes the `tv4` validator on a provided object.
	 *
	 * @private
	 * @throws {Errors.UnrecognizedParameterError}
	 * @throws {Errors.MissingParameterError}
	 * @throws {Errors.InvalidParameterError}
	 * @param {Object} obj - The object to validate.
	 * @param {Object} schema - A "JSON Schema" object
	 * @returns {void} This method will THROW if validation fails, but otherwise
	 *     it does not return anything.
	 */
	_validateObject( obj, schema ) {

		const me = this;

		// Dependencies
		const TV4		= me.$dep( "tv4" );
		const _			= me.$dep( "lodash" );
		// const ERRORS	= me.$dep( "errors" );

		// Prep Schema
		schema = me._prepareSchema( schema );

		// Apply definitions
		TV4.reset();

		let defs = me.definitions;

		if ( defs !== null ) {

			_.each( defs, function ( v, k ) {

				TV4.addSchema( k, v );
			} );
		}

		// Run tv4...
		if ( !TV4.validate( obj, schema ) ) {

			let err;

			if ( me.throwTv4Errors ) {

				err = TV4.error;

			} else {

				err = me._createValidationError( TV4.error );
			}

			throw err;
		}

		// Check for missing schemas
		if ( TV4.missing.length > 0 ) {

			throw new ERRORS.MissingSchemaDefinitionError(
				"Missing definition for $ref:" + TV4.missing[ 0 ]
			);
		}
	}

	// noinspection JSMethodCanBeStatic
	/**
	 * This method provides an error customization layer on top of `tv4`
	 * validation, which assists in making API errors, that are caused by
	 * request param validation failures, more intuitive to the client.
	 *
	 * @private
	 * @throws {Errors.UnrecognizedParameterError}
	 * @throws {Errors.MissingParameterError}
	 * @throws {Errors.InvalidParameterError}
	 * @see https://github.com/geraintluff/tv4/blob/master/tv4.js#L1427
	 * @param {Error} tv4error - An error generated by `tv4` during a failed
	 *     validation operation.
	 * @returns {Errors.BaseError} Validation error object.
	 */
	_createValidationError( tv4error ) {

		// const me = this;

		// Dependencies
		// const ERRORS = me.$dep( "errors" );

		let code 		= tv4error.code;
		let paramName	= tv4error.dataPath;
		let ErrorType 	= ERRORS.InvalidParameterError;

		// Determine if this validation error
		// applies to the root parameter object.

		// a. Remove any / prefixes
		paramName = paramName.replace( /^\//, "" );

		// b. Check for other slashes...
		let isRootParamError = true;

		if ( paramName.indexOf( "/" ) !== -1 ) {

			isRootParamError = false;
		}

		// Set default message prefix
		let msgPrefix = "Invalid request parameter '" + paramName + "'";

		// Apply overrides (if applicable)
		switch ( code ) {

			case 302:

				// Do not override non-root errors of this type.
				if ( isRootParamError ) {

					msgPrefix = "Invalid Request";

					tv4error.message =
						"Missing required parameter: " +
						"'" + tv4error.params.key + "'";

					ErrorType = ERRORS.MissingParameterError;
				}

				break;

			case 303:

				// Do not override non-root errors of this type.
				if ( isRootParamError ) {

					tv4error.message = "This parameter is not recognized";
					ErrorType = ERRORS.UnrecognizedParameterError;
				}

				break;

			default:

				// Do Nothing

				break;
		}

		// Wrap the tv4 error and return...
		return new ErrorType( tv4error, msgPrefix );
	}

	/**
	 * This method prepares the request schema for use by `tv4`
	 * by making a few, minor, alterations.
	 *
	 * @private
	 * @param {Object} original - The original requests schema.
	 * @returns {Object} A validation schema ready for use by `tv4`.
	 */
	_prepareSchema( original ) {

		const me = this;

		// Dependencies
		const _ = me.$dep( "lodash" );

		// Clone the original
		let schema = _.clone( original );

		// Make a few mods...
		if ( schema.id !== undefined ) {

			delete schema.id;
		}

		// The 'definitions' property should be plural
		if ( schema.definition !== undefined ) {

			if ( schema.definitions === undefined ) {

				schema.definitions = schema.definition;
			}

			delete schema.definition;
		}

		// Prohibit unrecognized parameters
		// (disabled, for now, will come back to it...)
		// -> schema.additionalProperties = false;

		// Done
		return schema;
	}
}

module.exports = Validator;
